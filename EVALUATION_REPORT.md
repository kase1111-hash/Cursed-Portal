# PROJECT EVALUATION REPORT

**Project:** Cursed Portal — Poe Parlor
**Primary Classification:** Good Concept, Bad Execution
**Secondary Tags:** Underdeveloped, Over-Engineered Documentation

---

## CONCEPT ASSESSMENT

**What real problem does this solve?**
It explores a genuinely interesting design space: using local LLMs as interactive NPCs in a horror game. Players talk to AI-driven incarnations of Edgar Allan Poe characters (The Raven, The Tell-Tale Heart narrator, Roderick Usher) while atmosphere escalates around them. The concept merges the unpredictability of LLM dialogue with environmental storytelling — a legitimate and timely game design experiment.

**Who is the user? Is the pain real or optional?**
Horror game enthusiasts and interactive fiction fans. The "pain" is optional — this is entertainment, not a utility. But the target audience is real: players who want emergent narrative experiences beyond scripted dialogue trees.

**Is this solved better elsewhere?**
AI Dungeon and similar text-adventure tools exist, but coupling LLM dialogue with a 3D first-person horror environment is a differentiated angle. The Poe theming adds creative focus. The local-LLM approach (Ollama/llama.cpp) is a defensible choice for privacy and offline play.

**Value prop in one sentence:**
A first-person gothic horror game where AI-powered Poe spirits respond dynamically to the player, escalating atmospheric dread through a 5-level spook system that culminates in a dimensional breach.

**Verdict:** Sound — the concept is creative, well-scoped to three spirits and one core gameplay loop, and targets a real intersection of LLM capabilities with game design. The Poe theming provides strong creative constraints that prevent scope from drifting into "generic AI chatbot."

---

## EXECUTION ASSESSMENT

### This is not a game. It is a specification that cosplays as a game.

The repository contains **44 C# script files (~11,500 lines)** and **13 documentation files (~140KB of markdown)**. It does not contain a functional Unity project. The following are entirely absent:

- **No `ProjectSettings/` folder** (mandatory for any Unity project to open)
- **No `Packages/manifest.json`** (required for Unity Package Manager)
- **No `.meta` files** (Unity's asset tracking — every file needs one)
- **No `.unity` scene files** (the actual game levels)
- **No prefabs, materials, shaders, audio clips, textures, or 3D models**
- **No `ProjectVersion.txt`**

This means: **the project cannot be opened in Unity**. It has never been compiled. It has never been run. It has never been playtested. The scripts reference assets (`Resources.Load("WhisperGeneric")`, material swaps, particle systems, AudioClips) that do not exist anywhere in the repository.

### Code Quality (evaluated as standalone C# scripts)

**Architecture:** Competent use of Unity patterns — singleton managers, coroutine-based async, event-driven communication via `EventManager`. The module decomposition (Core, AI, AudioVFX, UI, Props, Player, Editor) is clean.

**AI-Generated Boilerplate:** Every file carries `// Auto-generated by CursedPortal AI Spec v1.0` headers. The `AI-instructions.md` file explicitly instructs an LLM to generate these scripts module-by-module (M1–M25). The code reads like template output:
- Trivial getters wrapped in XML doc comments (`/// <summary>Gets the current game state.</summary>`)
- 13+ identical singleton implementations copy-pasted across files instead of using a generic `SingletonBase<T>`
- Switch statements with empty cases containing only comments (`case 1: // Orb glow, slight vignette break;` in `EventManager.cs`)
- Over-defensive null checks in places where null is structurally impossible

**Concurrency bugs:**
- `LLMStreamManager.cs`: `currentStreamCoroutine` is assigned outside the `streamLock`, then immediately nulled inside it. A second concurrent stream request will fail to cancel the first — both streams execute simultaneously, corrupting the chat display.
- `LLMManager.cs`: `LoadSpiritProfiles()` has no synchronization. Multiple coroutines calling `SummonSpirit()` simultaneously can trigger parallel file loads.

**Memory leaks:**
- `InteractableSpirit.cs`: Assigns to `.material` (not `.sharedMaterial`) on highlight, creating a new material instance every time the player looks at a prop. These instances are never cleaned up.
- All singletons use `DontDestroyOnLoad()` but never null their `Instance` reference in `OnDestroy()`, causing stale references across scene transitions.

**Incomplete implementations disguised as features:**
- `TriggerCameraShake()` in `EventManager.cs` logs to console but does nothing — yet camera shake is listed as a spook level 2 effect.
- `PostFXController.cs` loads a `Bloom` component reference that is never used.
- Multiple spook level switch cases (1, 3, 4) contain only comments, no code.
- `VoiceSynth.cs` is a TTS stub with no functional implementation.

**Verdict:** Execution does not match ambition. The ambition is a playable horror game. The execution is a collection of C# scripts that cannot compile without a Unity project shell, reference nonexistent assets, contain concurrency bugs, and have multiple features that are stubs logging to console. The documentation-to-code ratio (~140KB docs for ~11.5K lines of code) is inverted — the project has been specified more than it has been built.

---

## SCOPE ANALYSIS

**Core Feature:** LLM-powered spirit dialogue with escalating atmospheric horror (spook level 0–5)

**Supporting:**
- First-person player controller and raycast interaction system
- Chat UI for player-spirit communication
- Spirit memory persistence (remembers past conversations)
- Emotion parsing for dynamic atmosphere adjustment

**Nice-to-Have:**
- Streaming LLM responses with per-chunk emotion analysis
- Portal dimension breach sequence (level 5 finale)
- Debug UI with spook level slider
- Editor tooling for prefab/scene generation

**Distractions:**
- `VoiceSynth.cs` — TTS integration stub that does nothing
- `FootstepSystem.cs` — Optional system for a game that has no floor meshes
- `PropAnimator.cs` — Procedural animation for props that don't exist as assets
- `HeartbeatEffect.cs`, `CandleFlicker.cs`, `DimensionalLight.cs` — Atmospheric scripts for audio/light assets that aren't in the repo
- `Commercial_License.md` — Commercial licensing terms for a project that cannot run
- `KEYWORDS.md` (10KB of SEO keywords) — Marketing material for an uncompilable prototype

**Wrong Product:**
- `AI-instructions.md` + `Build_Guide.md` + `claude.md` — These are meta-documents for instructing an AI to generate the project. They are an AI prompt engineering toolkit, not part of the game itself. They belong in a separate "Cursed Portal Generator" repo.
- `AUDIT_REPORT.md` — A self-generated audit report. The project audited itself.
- `cursed_portal_build.yaml` — A build manifest that cannot execute because there is no Unity project to build.

**Scope Verdict:** Feature Creep + Multiple Products. The repository conflates three things: (1) a game concept specification, (2) an AI code generation prompt toolkit, and (3) the generated output scripts. The scope discipline within the scripts themselves is actually reasonable — 3 spirits, 4 props, 5 spook levels, 2 scenes. But the project-level scope is undisciplined: it invested heavily in documentation, SEO keywords, licensing, security policy, and contribution guidelines for software that has never executed.

---

## RECOMMENDATIONS

**CUT:**
- `KEYWORDS.md` — 10KB of SEO terms for a non-functional project
- `Commercial_License.md` — Premature licensing for uncompilable code
- `CONTRIBUTING.md` — Contribution guidelines for a solo AI-generated project
- `VoiceSynth.cs` — Stub with no implementation
- `FootstepSystem.cs` — No floor to walk on
- All empty switch cases in `EventManager.cs` — Either implement them or remove the comments promising features that don't exist
- The self-referential `AUDIT_REPORT.md` — Replace with actual test results once the project compiles

**DEFER:**
- Streaming LLM responses (`LLMStreamManager.cs`) — Get basic non-streaming working first
- Emotion parsing (`EmotionParser.cs`) — Nice polish, but the core loop works without it
- Spirit memory persistence (`SpiritMemory.cs`) — Deferrable until core gameplay is proven
- Portal/dimension breach sequence — Prove the base interaction loop first
- Editor automation tools — Only useful once there's a real Unity project to automate

**DOUBLE DOWN:**
- **Create an actual Unity project.** Add `ProjectSettings/`, `Packages/manifest.json`, scene files, and a single test scene with placeholder geometry. Until then, nothing else matters.
- **Get one spirit talking in one room.** Strip to: player controller + one prop + LLMManager + UIChat + one spirit. Prove the core loop compiles and runs.
- **Fix the concurrency bugs in `LLMStreamManager.cs`** before any streaming work continues. The race condition around `currentStreamCoroutine` will cause visible corruption.
- **Replace the 13 copy-pasted singleton implementations** with a `SingletonBase<T>` generic class. This is the single highest-ROI refactor.
- **Fix the material instance leak in `InteractableSpirit.cs`** — use `MaterialPropertyBlock` or `sharedMaterial` instead of `.material` assignment.

**FINAL VERDICT:** Reboot from scratch — but keep the scripts.

The concept is sound. The scripts are a reasonable starting point. But the project needs to be rebooted as an actual Unity project that compiles, runs, and proves the core interaction loop with one spirit in one room. Everything else — the 13 markdown files, the 25-module specification, the build manifest, the SEO keywords — is premature optimization of a product that does not yet exist.

**Next Step:** Create a new Unity 2023.2 LTS project with URP, import the Core + AI + UI scripts, create a single test scene with a cube as a prop, wire up `GameManager` → `EventManager` → `LLMManager` → `UIChat`, connect to a local Ollama instance, and get the Raven to say "Nevermore" in response to player input. That is the only thing that matters right now.
