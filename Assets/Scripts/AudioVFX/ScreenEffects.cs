// Auto-generated by CursedPortal AI Spec v1.0
// Source: Module M6 - Screen Effects

using UnityEngine;
using UnityEngine.UI;

/// <summary>
/// Manages screen-wide visual effects like flashes, fades, and overlays.
/// Used for dramatic moments and spook reactions.
/// </summary>
public class ScreenEffects : SceneSingletonBase<ScreenEffects>
{
    [Header("UI References")]
    [SerializeField] private Image flashImage;
    [SerializeField] private Image fadeImage;
    [SerializeField] private Image damageVignette;
    [SerializeField] private CanvasGroup overlayGroup;

    [Header("Flash Settings")]
    [SerializeField] private Color defaultFlashColor = Color.white;
    [SerializeField] private float defaultFlashDuration = 0.1f;

    [Header("Damage Vignette")]
    [SerializeField] private Color vignetteColor = new Color(0.5f, 0f, 0f, 0.5f);
    [SerializeField] private float vignetteFadeSpeed = 2f;

    // State
    private Coroutine flashCoroutine;
    private Coroutine fadeCoroutine;
    private float currentVignetteAlpha = 0f;

    private void Start()
    {
        // Initialize images
        if (flashImage != null)
        {
            flashImage.color = Color.clear;
            flashImage.raycastTarget = false;
        }

        if (fadeImage != null)
        {
            fadeImage.color = Color.clear;
            fadeImage.raycastTarget = false;
        }

        if (damageVignette != null)
        {
            damageVignette.color = Color.clear;
            damageVignette.raycastTarget = false;
        }
    }

    private void Update()
    {
        // Fade vignette over time
        if (damageVignette != null && currentVignetteAlpha > 0)
        {
            currentVignetteAlpha -= vignetteFadeSpeed * Time.deltaTime;
            currentVignetteAlpha = Mathf.Max(0f, currentVignetteAlpha);

            Color c = vignetteColor;
            c.a = currentVignetteAlpha;
            damageVignette.color = c;
        }
    }

    /// <summary>
    /// Triggers a screen flash.
    /// </summary>
    public void Flash(Color? color = null, float duration = -1f)
    {
        Color flashColor = color ?? defaultFlashColor;
        float flashDuration = duration > 0 ? duration : defaultFlashDuration;

        if (flashCoroutine != null)
        {
            StopCoroutine(flashCoroutine);
        }
        flashCoroutine = StartCoroutine(FlashCoroutine(flashColor, flashDuration));
    }

    private System.Collections.IEnumerator FlashCoroutine(Color color, float duration)
    {
        if (flashImage == null) yield break;

        flashImage.color = color;

        float elapsed = 0f;
        while (elapsed < duration)
        {
            elapsed += Time.deltaTime;
            float t = elapsed / duration;

            Color c = color;
            c.a = Mathf.Lerp(color.a, 0f, t);
            flashImage.color = c;

            yield return null;
        }

        flashImage.color = Color.clear;
    }

    /// <summary>
    /// Triggers a red terror flash.
    /// </summary>
    public void TerrorFlash()
    {
        Flash(new Color(0.8f, 0f, 0f, 0.6f), 0.15f);
    }

    /// <summary>
    /// Triggers a white spirit flash.
    /// </summary>
    public void SpiritFlash()
    {
        Flash(new Color(0.8f, 0.8f, 1f, 0.5f), 0.2f);
    }

    /// <summary>
    /// Fades the screen to a color.
    /// </summary>
    public void FadeTo(Color color, float duration, System.Action onComplete = null)
    {
        if (fadeCoroutine != null)
        {
            StopCoroutine(fadeCoroutine);
        }
        fadeCoroutine = StartCoroutine(FadeCoroutine(fadeImage.color, color, duration, onComplete));
    }

    /// <summary>
    /// Fades to black.
    /// </summary>
    public void FadeToBlack(float duration, System.Action onComplete = null)
    {
        FadeTo(Color.black, duration, onComplete);
    }

    /// <summary>
    /// Fades from current to clear.
    /// </summary>
    public void FadeIn(float duration, System.Action onComplete = null)
    {
        FadeTo(Color.clear, duration, onComplete);
    }

    private System.Collections.IEnumerator FadeCoroutine(Color from, Color to, float duration, System.Action onComplete)
    {
        if (fadeImage == null) yield break;

        fadeImage.raycastTarget = to.a > 0.5f; // Block input during heavy fade

        float elapsed = 0f;
        while (elapsed < duration)
        {
            elapsed += Time.deltaTime;
            float t = elapsed / duration;

            fadeImage.color = Color.Lerp(from, to, t);
            yield return null;
        }

        fadeImage.color = to;
        fadeImage.raycastTarget = false;
        onComplete?.Invoke();
    }

    /// <summary>
    /// Pulses the damage vignette.
    /// </summary>
    public void PulseVignette(float intensity = 0.5f)
    {
        currentVignetteAlpha = Mathf.Max(currentVignetteAlpha, intensity);
    }

    /// <summary>
    /// Sets persistent vignette alpha.
    /// </summary>
    public void SetVignetteAlpha(float alpha)
    {
        currentVignetteAlpha = alpha;
    }

    /// <summary>
    /// Creates a glitch effect (multiple rapid flashes).
    /// </summary>
    public void GlitchEffect(float duration = 0.5f)
    {
        StartCoroutine(GlitchCoroutine(duration));
    }

    private System.Collections.IEnumerator GlitchCoroutine(float duration)
    {
        float elapsed = 0f;
        Color[] glitchColors = {
            new Color(1f, 0f, 0f, 0.3f),
            new Color(0f, 1f, 0f, 0.3f),
            new Color(0f, 0f, 1f, 0.3f),
            new Color(1f, 1f, 1f, 0.5f),
            Color.clear
        };

        while (elapsed < duration)
        {
            if (flashImage != null)
            {
                flashImage.color = glitchColors[Random.Range(0, glitchColors.Length)];
            }

            float waitTime = Random.Range(0.02f, 0.08f);
            yield return new WaitForSeconds(waitTime);
            elapsed += waitTime;
        }

        if (flashImage != null)
        {
            flashImage.color = Color.clear;
        }
    }

    /// <summary>
    /// Shows the "DIMENSION BREACH" overlay effect.
    /// </summary>
    public void ShowBreachOverlay()
    {
        if (overlayGroup != null)
        {
            overlayGroup.alpha = 1f;
            StartCoroutine(PulseOverlay());
        }
    }

    private System.Collections.IEnumerator PulseOverlay()
    {
        while (overlayGroup != null && overlayGroup.alpha > 0)
        {
            float pulse = 0.7f + Mathf.Sin(Time.time * 5f) * 0.3f;
            overlayGroup.alpha = pulse;
            yield return null;
        }
    }

    /// <summary>
    /// Hides the breach overlay.
    /// </summary>
    public void HideBreachOverlay()
    {
        if (overlayGroup != null)
        {
            overlayGroup.alpha = 0f;
        }
    }
}
