// Auto-generated by CursedPortal AI Spec v1.0
// Source: Module M5 - Atmosphere Effects

using UnityEngine;

/// <summary>
/// Creates flickering candle/lamp effect on lights.
/// Attach to any Light component for atmospheric effect.
/// </summary>
public class CandleFlicker : MonoBehaviour
{
    [Header("Flicker Settings")]
    [SerializeField] private float baseIntensity = 1f;
    [SerializeField] private float flickerIntensity = 0.3f;
    [SerializeField] private float flickerSpeed = 8f;
    [SerializeField] private float smoothing = 5f;

    [Header("Color Variation")]
    [SerializeField] private bool useColorFlicker = true;
    [SerializeField] private Color baseColor = new Color(1f, 0.8f, 0.5f); // Warm candle
    [SerializeField] private Color flickerColor = new Color(1f, 0.6f, 0.3f);
    [SerializeField] private float colorFlickerAmount = 0.2f;

    [Header("Spook Response")]
    [SerializeField] private bool respondToSpook = true;
    [SerializeField] private float spookFlickerMultiplier = 2f;
    [SerializeField] private float spookDimAmount = 0.3f;

    // Components
    private Light targetLight;

    // State
    private float currentIntensity;
    private float targetIntensity;
    private float noiseOffset;
    private int currentSpookLevel = 0;

    private void Awake()
    {
        targetLight = GetComponent<Light>();
        if (targetLight == null)
        {
            Debug.LogError("[CandleFlicker] No Light component found!");
            enabled = false;
            return;
        }

        noiseOffset = Random.value * 100f;
        currentIntensity = baseIntensity;
        targetLight.intensity = baseIntensity;
        targetLight.color = baseColor;
    }

    private void Start()
    {
        if (respondToSpook && EventManager.Instance != null)
        {
            EventManager.Instance.OnSpookLevelChanged += OnSpookLevelChanged;
        }
    }

    private void Update()
    {
        UpdateFlicker();
        UpdateColor();
    }

    /// <summary>
    /// Updates the light intensity flicker.
    /// </summary>
    private void UpdateFlicker()
    {
        // Multiple noise layers for organic feel
        float noise1 = Mathf.PerlinNoise(Time.time * flickerSpeed, noiseOffset);
        float noise2 = Mathf.PerlinNoise(Time.time * flickerSpeed * 2f, noiseOffset + 10f) * 0.5f;
        float noise3 = Mathf.PerlinNoise(Time.time * flickerSpeed * 0.5f, noiseOffset + 20f) * 0.3f;

        float combinedNoise = (noise1 + noise2 + noise3) / 1.8f;

        // Calculate flicker amount based on spook level
        float currentFlickerIntensity = flickerIntensity;
        if (respondToSpook)
        {
            currentFlickerIntensity *= 1f + (currentSpookLevel * spookFlickerMultiplier * 0.2f);
        }

        // Calculate target intensity
        float spookDim = respondToSpook ? (currentSpookLevel * spookDimAmount * 0.1f) : 0f;
        targetIntensity = baseIntensity - spookDim + (combinedNoise * 2f - 1f) * currentFlickerIntensity;
        targetIntensity = Mathf.Max(0.1f, targetIntensity);

        // Smooth transition
        currentIntensity = Mathf.Lerp(currentIntensity, targetIntensity, smoothing * Time.deltaTime);
        targetLight.intensity = currentIntensity;

        // Random brief flicker (sputter)
        if (Random.value < 0.002f * (1f + currentSpookLevel))
        {
            targetLight.intensity *= Random.Range(0.3f, 0.7f);
        }
    }

    /// <summary>
    /// Updates the light color variation.
    /// </summary>
    private void UpdateColor()
    {
        if (!useColorFlicker) return;

        float colorNoise = Mathf.PerlinNoise(Time.time * flickerSpeed * 0.3f, noiseOffset + 50f);
        float colorLerp = colorNoise * colorFlickerAmount;

        // Shift toward cooler colors at higher spook levels
        Color spookTint = Color.Lerp(baseColor, new Color(0.5f, 0.3f, 0.8f), currentSpookLevel * 0.1f);
        Color targetColor = Color.Lerp(spookTint, flickerColor, colorLerp);

        targetLight.color = targetColor;
    }

    /// <summary>
    /// Called when spook level changes.
    /// </summary>
    private void OnSpookLevelChanged(int level)
    {
        currentSpookLevel = level;

        // Dramatic flicker on level change
        if (level > 0)
        {
            StartCoroutine(DramaticFlicker());
        }
    }

    /// <summary>
    /// Performs a dramatic flicker sequence.
    /// </summary>
    private System.Collections.IEnumerator DramaticFlicker()
    {
        float originalBase = baseIntensity;

        // Quick flickers
        for (int i = 0; i < 3; i++)
        {
            targetLight.intensity = originalBase * 0.2f;
            yield return new WaitForSeconds(0.05f);
            targetLight.intensity = originalBase * 1.5f;
            yield return new WaitForSeconds(0.05f);
        }

        // Brief blackout at high spook
        if (currentSpookLevel >= 4)
        {
            targetLight.intensity = 0f;
            yield return new WaitForSeconds(0.3f);
        }

        targetLight.intensity = originalBase;
    }

    /// <summary>
    /// Forces the light off temporarily.
    /// </summary>
    public void ForceOff(float duration)
    {
        StartCoroutine(ForceOffCoroutine(duration));
    }

    private System.Collections.IEnumerator ForceOffCoroutine(float duration)
    {
        float originalBase = baseIntensity;
        baseIntensity = 0f;
        yield return new WaitForSeconds(duration);
        baseIntensity = originalBase;
    }

    /// <summary>
    /// Sets the base intensity.
    /// </summary>
    public void SetBaseIntensity(float intensity)
    {
        baseIntensity = intensity;
    }

    private void OnDestroy()
    {
        if (EventManager.Instance != null)
        {
            EventManager.Instance.OnSpookLevelChanged -= OnSpookLevelChanged;
        }
    }
}
