// Auto-generated by CursedPortal AI Spec v1.0
// Source: Module M4 - Spook Triggers

using UnityEngine;

/// <summary>
/// Trigger zone that affects spook level when player enters.
/// Use for area-based horror moments and environmental storytelling.
/// </summary>
[RequireComponent(typeof(Collider))]
public class SpookTriggerZone : MonoBehaviour
{
    [Header("Trigger Settings")]
    [SerializeField] private TriggerType triggerType = TriggerType.IncrementOnEnter;
    [SerializeField] private int spookChange = 1;
    [SerializeField] private bool oneShot = true;

    [Header("Effects")]
    [SerializeField] private bool triggerCameraShake = false;
    [SerializeField] private float shakeIntensity = 0.3f;
    [SerializeField] private bool triggerScreenFlash = false;
    [SerializeField] private Color flashColor = Color.white;
    [SerializeField] private bool playSound = false;
    [SerializeField] private AudioClip triggerSound;

    [Header("Spirit Summon")]
    [SerializeField] private bool summonSpirit = false;
    [SerializeField] private string spiritKey = "Raven";

    [Header("Timing")]
    [SerializeField] private float triggerDelay = 0f;
    [SerializeField] private float cooldown = 5f;

    public enum TriggerType
    {
        IncrementOnEnter,
        DecrementOnEnter,
        IncrementWhileInside,
        SetLevel
    }

    // State
    private bool hasTriggered = false;
    private bool playerInside = false;
    private float lastTriggerTime = -999f;
    private float insideTimer = 0f;

    [Header("While Inside Settings")]
    [SerializeField] private float insideIncrementInterval = 3f;

    private void Start()
    {
        // Ensure collider is trigger
        Collider col = GetComponent<Collider>();
        if (col != null)
        {
            col.isTrigger = true;
        }
    }

    private void Update()
    {
        // Handle continuous effect while inside
        if (playerInside && triggerType == TriggerType.IncrementWhileInside)
        {
            insideTimer += Time.deltaTime;

            if (insideTimer >= insideIncrementInterval)
            {
                insideTimer = 0f;
                ApplySpookEffect();
            }
        }
    }

    private void OnTriggerEnter(Collider other)
    {
        if (!other.CompareTag("Player")) return;

        playerInside = true;

        // Check cooldown and one-shot
        if (oneShot && hasTriggered) return;
        if (Time.time - lastTriggerTime < cooldown) return;

        if (triggerType != TriggerType.IncrementWhileInside)
        {
            if (triggerDelay > 0)
            {
                Invoke(nameof(DelayedTrigger), triggerDelay);
            }
            else
            {
                ExecuteTrigger();
            }
        }
    }

    private void OnTriggerExit(Collider other)
    {
        if (!other.CompareTag("Player")) return;

        playerInside = false;
        insideTimer = 0f;
    }

    private void DelayedTrigger()
    {
        if (playerInside || !oneShot)
        {
            ExecuteTrigger();
        }
    }

    /// <summary>
    /// Executes the trigger effects.
    /// </summary>
    private void ExecuteTrigger()
    {
        hasTriggered = true;
        lastTriggerTime = Time.time;

        Debug.Log($"[SpookTriggerZone] Triggered: {gameObject.name}");

        // Apply spook effect
        ApplySpookEffect();

        // Additional effects
        if (triggerCameraShake && CameraShake.Instance != null)
        {
            CameraShake.Instance.Shake(shakeIntensity);
        }

        if (triggerScreenFlash && ScreenEffects.Instance != null)
        {
            ScreenEffects.Instance.Flash(flashColor);
        }

        if (playSound && triggerSound != null && AudioManager.Instance != null)
        {
            AudioManager.Instance.PlaySFX(triggerSound);
        }

        if (summonSpirit && LLMManager.Instance != null)
        {
            LLMManager.Instance.SummonSpirit(spiritKey);
        }
    }

    /// <summary>
    /// Applies the spook level change.
    /// </summary>
    private void ApplySpookEffect()
    {
        if (EventManager.Instance == null) return;

        switch (triggerType)
        {
            case TriggerType.IncrementOnEnter:
            case TriggerType.IncrementWhileInside:
                EventManager.Instance.IncrementSpook(spookChange);
                break;

            case TriggerType.DecrementOnEnter:
                EventManager.Instance.DecrementSpook(spookChange);
                break;

            case TriggerType.SetLevel:
                EventManager.Instance.SetSpookLevel(spookChange);
                break;
        }
    }

    /// <summary>
    /// Resets the trigger (for reusable zones).
    /// </summary>
    public void ResetTrigger()
    {
        hasTriggered = false;
        lastTriggerTime = -999f;
    }

    /// <summary>
    /// Forces the trigger to activate.
    /// </summary>
    public void ForceTrigger()
    {
        ExecuteTrigger();
    }

    private void OnDrawGizmos()
    {
        // Visualize trigger zone
        Collider col = GetComponent<Collider>();
        if (col == null) return;

        Gizmos.color = hasTriggered ? new Color(0.5f, 0.5f, 0.5f, 0.3f) :
                       triggerType == TriggerType.IncrementOnEnter ? new Color(1f, 0f, 0f, 0.3f) :
                       triggerType == TriggerType.DecrementOnEnter ? new Color(0f, 1f, 0f, 0.3f) :
                       new Color(1f, 0.5f, 0f, 0.3f);

        if (col is BoxCollider box)
        {
            Gizmos.matrix = transform.localToWorldMatrix;
            Gizmos.DrawCube(box.center, box.size);
            Gizmos.DrawWireCube(box.center, box.size);
        }
        else if (col is SphereCollider sphere)
        {
            Gizmos.DrawSphere(transform.position + sphere.center, sphere.radius);
            Gizmos.DrawWireSphere(transform.position + sphere.center, sphere.radius);
        }
    }

    private void OnDrawGizmosSelected()
    {
        // Show trigger info
        Gizmos.color = Color.yellow;
        Gizmos.DrawLine(transform.position, transform.position + Vector3.up * 2f);
    }
}
