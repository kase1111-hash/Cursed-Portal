// Auto-generated by CursedPortal AI Spec v1.0
// Source: Module M17

using UnityEngine;

/// <summary>
/// Global system coordinator that orchestrates emotion, VFX, and sound per frame.
/// Acts as the ritual heartbeat of the Cursed Portal experience.
/// </summary>
public class RitualLoop : SingletonBase<RitualLoop>
{
    [Header("Update Settings")]
    [SerializeField] private bool useFixedTimestep = false;
    [SerializeField] private float updateInterval = 0.5f; // Seconds between updates if fixed

    [Header("Smooth Transitions")]
    [SerializeField] private float fogLerpSpeed = 2f;
    [SerializeField] private float audioLerpSpeed = 3f;

    // State tracking
    private float lastUpdateTime = 0f;
    private string currentEmotion = EmotionParser.NEUTRAL;
    private float emotionIntensity = 0f;
    private float emotionDecayRate = 0.1f; // Per second

    // Target values for smooth transitions
    private float targetFogDensity = 0.01f;
    private float targetAudioVolume = 0.3f;

    private void Update()
    {
        if (useFixedTimestep)
        {
            if (Time.time - lastUpdateTime >= updateInterval)
            {
                lastUpdateTime = Time.time;
                PerformRitualUpdate();
            }
        }
        else
        {
            PerformRitualUpdate();
        }

        // Always update smooth transitions
        UpdateSmoothTransitions();

        // Decay emotion intensity over time
        DecayEmotion();
    }

    /// <summary>
    /// Main ritual update - synchronizes all systems with current spook level.
    /// </summary>
    private void PerformRitualUpdate()
    {
        int level = EventManager.Instance?.SpookLevel ?? 0;

        // Calculate target values based on level
        targetFogDensity = 0.01f + (level * 0.04f);
        targetAudioVolume = 0.3f + (level * 0.1f);

        // Apply emotion modifiers
        if (currentEmotion == EmotionParser.TERROR)
        {
            targetFogDensity += emotionIntensity * 0.02f;
            targetAudioVolume += emotionIntensity * 0.1f;
        }
        else if (currentEmotion == EmotionParser.UNEASE)
        {
            targetFogDensity += emotionIntensity * 0.01f;
        }
    }

    /// <summary>
    /// Smoothly interpolates visual and audio parameters.
    /// </summary>
    private void UpdateSmoothTransitions()
    {
        // Smooth fog transition
        if (VFXManager.Instance != null)
        {
            float currentFog = RenderSettings.fogDensity;
            float newFog = Mathf.Lerp(currentFog, targetFogDensity, fogLerpSpeed * Time.deltaTime);
            RenderSettings.fogDensity = newFog;
        }

        // Note: Audio transitions handled by AudioManager.UpdateAmbience
    }

    /// <summary>
    /// Decays emotion intensity over time back to neutral.
    /// </summary>
    private void DecayEmotion()
    {
        if (emotionIntensity > 0)
        {
            emotionIntensity -= emotionDecayRate * Time.deltaTime;
            emotionIntensity = Mathf.Max(0f, emotionIntensity);

            if (emotionIntensity <= 0)
            {
                currentEmotion = EmotionParser.NEUTRAL;
            }
        }
    }

    /// <summary>
    /// Reacts to a spook level change event.
    /// </summary>
    /// <param name="level">New spook level</param>
    public void ReactToLevel(int level)
    {
        Debug.Log($"[RitualLoop] Reacting to level {level}");

        // Trigger level-specific ambient changes
        switch (level)
        {
            case 1:
                // Subtle glow
                break;
            case 2:
                // Fog thickening
                break;
            case 3:
                // Phantom appearances
                if (VFXManager.Instance != null)
                {
                    VFXManager.Instance.EnableGhosts();
                }
                break;
            case 4:
                // Visual distortion
                if (PostFXController.Instance != null)
                {
                    PostFXController.Instance.TriggerGlitch(0.2f);
                }
                break;
            case 5:
                // Dimension breach
                break;
        }
    }

    /// <summary>
    /// Reacts to detected emotion from LLM responses.
    /// </summary>
    /// <param name="emotion">Detected emotion category</param>
    public void ReactToEmotion(string emotion)
    {
        currentEmotion = emotion;
        emotionIntensity = 1f; // Reset intensity on new emotion

        Debug.Log($"[RitualLoop] Emotion reaction: {emotion}");

        // Immediate reactions based on emotion
        switch (emotion)
        {
            case EmotionParser.TERROR:
                // Pulse vignette
                if (PostFXController.Instance != null)
                {
                    PostFXController.Instance.PulseVignette(0.8f, 0.5f);
                }

                // Add fog burst
                if (VFXManager.Instance != null)
                {
                    VFXManager.Instance.AddFogBurst(0.02f);
                }

                // Heartbeat
                if (AudioManager.Instance != null)
                {
                    AudioManager.Instance.PlayHeartbeat();
                }
                break;

            case EmotionParser.UNEASE:
                // Subtle vignette pulse
                if (PostFXController.Instance != null)
                {
                    PostFXController.Instance.PulseVignette(0.5f, 1f);
                }
                break;

            case EmotionParser.NEUTRAL:
                // No immediate reaction
                break;
        }

        // Update portal distortion
        if (PortalDistort.Instance != null)
        {
            PortalDistort.Instance.SetEmotion(emotion);
        }
    }

    /// <summary>
    /// Gets the current emotion state.
    /// </summary>
    public string GetCurrentEmotion()
    {
        return currentEmotion;
    }

    /// <summary>
    /// Gets the current emotion intensity (0-1).
    /// </summary>
    public float GetEmotionIntensity()
    {
        return emotionIntensity;
    }

    /// <summary>
    /// Forces an immediate ritual state update.
    /// </summary>
    public void ForceUpdate()
    {
        PerformRitualUpdate();

        // Immediately apply values without smooth transition
        RenderSettings.fogDensity = targetFogDensity;

        if (AudioManager.Instance != null)
        {
            AudioManager.Instance.UpdateAmbience(EventManager.Instance?.SpookLevel ?? 0);
        }

        if (PostFXController.Instance != null)
        {
            PostFXController.Instance.SetLevel(EventManager.Instance?.SpookLevel ?? 0);
        }
    }

    /// <summary>
    /// Resets the ritual loop to initial state.
    /// </summary>
    public void Reset()
    {
        currentEmotion = EmotionParser.NEUTRAL;
        emotionIntensity = 0f;
        targetFogDensity = 0.01f;
        targetAudioVolume = 0.3f;

        ForceUpdate();
        Debug.Log("[RitualLoop] Reset to initial state");
    }

}
