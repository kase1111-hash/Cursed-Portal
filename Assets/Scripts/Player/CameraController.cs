// Auto-generated by CursedPortal AI Spec v1.0
// Source: Module M1 - Player Systems

using UnityEngine;

/// <summary>
/// First-person camera controller with mouse look.
/// Handles vertical (pitch) and horizontal (yaw) rotation.
/// </summary>
public class CameraController : SceneSingletonBase<CameraController>
{
    [Header("Mouse Look Settings")]
    [SerializeField] private float mouseSensitivity = 2f;
    [SerializeField] private float smoothing = 2f;
    [SerializeField] private bool invertY = false;

    [Header("Vertical Limits")]
    [SerializeField] private float minPitch = -80f;
    [SerializeField] private float maxPitch = 80f;

    [Header("References")]
    [SerializeField] private Transform playerBody;

    [Header("Field of View")]
    [SerializeField] private float baseFOV = 70f;
    [SerializeField] private float sprintFOV = 80f;
    [SerializeField] private float fovLerpSpeed = 5f;

    [Header("Camera Shake")]
    [SerializeField] private float shakeDecay = 1.5f;

    // Look state
    private Vector2 currentLookDelta;
    private Vector2 smoothLookDelta;
    private float currentPitch;
    private float currentYaw;

    // Camera components
    private Camera cam;
    private float targetFOV;

    // Shake state
    private float shakeIntensity;
    private Vector3 shakeOffset;

    // Control state
    private bool canLook = true;

    protected override void Awake()
    {
        base.Awake();
        if (Instance == this)
        {
            cam = GetComponent<Camera>();
            if (cam == null)
            {
                cam = Camera.main;
            }

            // Auto-find player body if not assigned
            if (playerBody == null)
            {
                playerBody = transform.parent;
            }

            targetFOV = baseFOV;
        }
    }

    private void Start()
    {
        // Initialize rotation from current transform
        currentYaw = playerBody != null ? playerBody.eulerAngles.y : 0f;
        currentPitch = transform.localEulerAngles.x;

        // Normalize pitch
        if (currentPitch > 180f)
        {
            currentPitch -= 360f;
        }

        // Set initial FOV
        if (cam != null)
        {
            cam.fieldOfView = baseFOV;
        }
    }

    private void Update()
    {
        if (!canLook) return;

        // Don't process look input if chat is open
        if (UIChat.Instance != null && UIChat.Instance.IsVisible())
        {
            return;
        }

        HandleMouseLook();
        HandleFOV();
        HandleShake();
    }

    private void LateUpdate()
    {
        ApplyRotation();
    }

    /// <summary>
    /// Handles mouse look input.
    /// </summary>
    private void HandleMouseLook()
    {
        // Get raw mouse input
        float mouseX = Input.GetAxisRaw("Mouse X") * mouseSensitivity;
        float mouseY = Input.GetAxisRaw("Mouse Y") * mouseSensitivity;

        // Invert Y if needed
        if (invertY)
        {
            mouseY = -mouseY;
        }

        // Smooth the input
        currentLookDelta = new Vector2(mouseX, mouseY);
        smoothLookDelta = Vector2.Lerp(smoothLookDelta, currentLookDelta, 1f / smoothing);

        // Apply to rotation values
        currentYaw += smoothLookDelta.x;
        currentPitch -= smoothLookDelta.y;

        // Clamp vertical rotation
        currentPitch = Mathf.Clamp(currentPitch, minPitch, maxPitch);
    }

    /// <summary>
    /// Applies the calculated rotation.
    /// </summary>
    private void ApplyRotation()
    {
        // Apply yaw to player body (horizontal)
        if (playerBody != null)
        {
            playerBody.rotation = Quaternion.Euler(0f, currentYaw, 0f);
        }

        // Apply pitch to camera (vertical) with shake offset
        Vector3 finalRotation = new Vector3(currentPitch, 0f, 0f) + shakeOffset;
        transform.localRotation = Quaternion.Euler(finalRotation);
    }

    /// <summary>
    /// Handles FOV changes (sprint effect).
    /// </summary>
    private void HandleFOV()
    {
        if (cam == null) return;

        // Check if player is sprinting
        bool isSprinting = Input.GetKey(KeyCode.LeftShift) &&
                          FirstPersonController.Instance != null &&
                          FirstPersonController.Instance.IsMoving();

        targetFOV = isSprinting ? sprintFOV : baseFOV;
        cam.fieldOfView = Mathf.Lerp(cam.fieldOfView, targetFOV, fovLerpSpeed * Time.deltaTime);
    }

    /// <summary>
    /// Handles camera shake decay.
    /// </summary>
    private void HandleShake()
    {
        if (shakeIntensity > 0)
        {
            // Generate random shake offset
            shakeOffset = new Vector3(
                Random.Range(-1f, 1f) * shakeIntensity,
                Random.Range(-1f, 1f) * shakeIntensity,
                0f
            );

            // Decay shake
            shakeIntensity -= shakeDecay * Time.deltaTime;
            shakeIntensity = Mathf.Max(0f, shakeIntensity);
        }
        else
        {
            shakeOffset = Vector3.zero;
        }
    }

    /// <summary>
    /// Triggers camera shake.
    /// </summary>
    /// <param name="intensity">Shake intensity</param>
    /// <param name="duration">Duration (affects decay rate)</param>
    public void Shake(float intensity, float duration = 0.5f)
    {
        shakeIntensity = intensity;
        shakeDecay = intensity / duration;
        Debug.Log($"[CameraController] Shake triggered: intensity={intensity}");
    }

    /// <summary>
    /// Sets whether camera look is enabled.
    /// </summary>
    public void SetCanLook(bool value)
    {
        canLook = value;
    }

    /// <summary>
    /// Sets mouse sensitivity.
    /// </summary>
    public void SetSensitivity(float sensitivity)
    {
        mouseSensitivity = sensitivity;
    }

    /// <summary>
    /// Gets current mouse sensitivity.
    /// </summary>
    public float GetSensitivity()
    {
        return mouseSensitivity;
    }

    /// <summary>
    /// Snaps look direction to a target.
    /// </summary>
    public void LookAt(Vector3 targetPosition)
    {
        if (playerBody == null) return;

        Vector3 direction = targetPosition - transform.position;
        direction.y = 0f; // Keep horizontal

        if (direction.magnitude > 0.1f)
        {
            currentYaw = Quaternion.LookRotation(direction).eulerAngles.y;
        }

        // Calculate pitch to target
        direction = targetPosition - transform.position;
        currentPitch = -Mathf.Atan2(direction.y, new Vector2(direction.x, direction.z).magnitude) * Mathf.Rad2Deg;
        currentPitch = Mathf.Clamp(currentPitch, minPitch, maxPitch);
    }

    /// <summary>
    /// Gets the camera's forward direction.
    /// </summary>
    public Vector3 GetLookDirection()
    {
        return transform.forward;
    }

    /// <summary>
    /// Sets FOV override (for effects).
    /// </summary>
    public void SetFOVOverride(float fov)
    {
        if (cam != null)
        {
            cam.fieldOfView = fov;
        }
    }

    /// <summary>
    /// Resets FOV to base value.
    /// </summary>
    public void ResetFOV()
    {
        targetFOV = baseFOV;
    }
}
