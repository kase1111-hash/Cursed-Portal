// Auto-generated by CursedPortal AI Spec v1.0
// Source: Module M8 - Prop Highlight System

using UnityEngine;

/// <summary>
/// Handles visual highlighting of interactable props.
/// Supports outline glow, emission boost, and scale pulse effects.
/// </summary>
public class PropHighlight : MonoBehaviour
{
    [Header("Highlight Type")]
    [SerializeField] private HighlightMode highlightMode = HighlightMode.Emission;
    [SerializeField] private bool useScalePulse = true;

    [Header("Emission Settings")]
    [SerializeField] private Color highlightColor = new Color(0.5f, 0.3f, 0.8f);
    [SerializeField] private float highlightIntensity = 2f;
    [SerializeField] private float normalIntensity = 0f;
    [SerializeField] private string emissionProperty = "_EmissionColor";

    [Header("Outline Settings")]
    [SerializeField] private Material outlineMaterial;
    [SerializeField] private float outlineWidth = 0.02f;
    [SerializeField] private Color outlineColor = new Color(0.6f, 0.4f, 1f);

    [Header("Scale Pulse")]
    [SerializeField] private float pulseAmount = 0.05f;
    [SerializeField] private float pulseSpeed = 3f;

    [Header("Transition")]
    [SerializeField] private float transitionSpeed = 8f;

    public enum HighlightMode
    {
        Emission,
        Outline,
        Both
    }

    // State
    private bool isHighlighted = false;
    private float currentIntensity = 0f;
    private Vector3 originalScale;
    private Renderer[] renderers;
    private Material[] originalMaterials;
    private Material[] highlightMaterials;
    private GameObject outlineObject;

    private void Start()
    {
        originalScale = transform.localScale;
        renderers = GetComponentsInChildren<Renderer>();

        // Cache original materials and create highlight versions
        CacheMaterials();

        // Setup outline if needed
        if (highlightMode == HighlightMode.Outline || highlightMode == HighlightMode.Both)
        {
            SetupOutline();
        }
    }

    /// <summary>
    /// Caches materials for emission highlighting.
    /// </summary>
    private void CacheMaterials()
    {
        if (renderers == null || renderers.Length == 0) return;

        originalMaterials = new Material[renderers.Length];
        highlightMaterials = new Material[renderers.Length];

        for (int i = 0; i < renderers.Length; i++)
        {
            if (renderers[i] != null)
            {
                originalMaterials[i] = renderers[i].material;
                highlightMaterials[i] = new Material(originalMaterials[i]);

                // Enable emission keyword
                if (highlightMaterials[i].HasProperty(emissionProperty))
                {
                    highlightMaterials[i].EnableKeyword("_EMISSION");
                }
            }
        }
    }

    /// <summary>
    /// Sets up outline effect using a scaled duplicate mesh.
    /// </summary>
    private void SetupOutline()
    {
        if (outlineMaterial == null)
        {
            // Create simple outline material
            outlineMaterial = new Material(Shader.Find("Unlit/Color"));
            if (outlineMaterial != null)
            {
                outlineMaterial.color = outlineColor;
            }
        }

        // Create outline object
        MeshFilter meshFilter = GetComponent<MeshFilter>();
        if (meshFilter != null && meshFilter.sharedMesh != null)
        {
            outlineObject = new GameObject("Outline");
            outlineObject.transform.SetParent(transform);
            outlineObject.transform.localPosition = Vector3.zero;
            outlineObject.transform.localRotation = Quaternion.identity;
            outlineObject.transform.localScale = Vector3.one * (1f + outlineWidth);

            MeshFilter outlineMeshFilter = outlineObject.AddComponent<MeshFilter>();
            outlineMeshFilter.sharedMesh = meshFilter.sharedMesh;

            MeshRenderer outlineRenderer = outlineObject.AddComponent<MeshRenderer>();
            outlineRenderer.material = outlineMaterial;
            outlineRenderer.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.Off;
            outlineRenderer.receiveShadows = false;

            outlineObject.SetActive(false);
        }
    }

    private void Update()
    {
        UpdateHighlight();
        UpdateScalePulse();
    }

    /// <summary>
    /// Updates highlight effect interpolation.
    /// </summary>
    private void UpdateHighlight()
    {
        float targetIntensity = isHighlighted ? highlightIntensity : normalIntensity;
        currentIntensity = Mathf.Lerp(currentIntensity, targetIntensity, transitionSpeed * Time.deltaTime);

        // Apply emission
        if (highlightMode == HighlightMode.Emission || highlightMode == HighlightMode.Both)
        {
            ApplyEmission();
        }

        // Apply outline
        if (highlightMode == HighlightMode.Outline || highlightMode == HighlightMode.Both)
        {
            ApplyOutline();
        }
    }

    /// <summary>
    /// Applies emission-based highlight to materials.
    /// </summary>
    private void ApplyEmission()
    {
        if (highlightMaterials == null) return;

        Color emissionColor = highlightColor * currentIntensity;

        for (int i = 0; i < renderers.Length; i++)
        {
            if (renderers[i] != null && highlightMaterials[i] != null)
            {
                if (highlightMaterials[i].HasProperty(emissionProperty))
                {
                    highlightMaterials[i].SetColor(emissionProperty, emissionColor);
                }
                renderers[i].material = highlightMaterials[i];
            }
        }
    }

    /// <summary>
    /// Applies outline visibility.
    /// </summary>
    private void ApplyOutline()
    {
        if (outlineObject != null)
        {
            bool shouldShow = currentIntensity > 0.1f;
            if (outlineObject.activeSelf != shouldShow)
            {
                outlineObject.SetActive(shouldShow);
            }

            // Pulse outline alpha
            if (shouldShow && outlineMaterial != null)
            {
                float alpha = 0.5f + Mathf.Sin(Time.time * pulseSpeed) * 0.3f;
                Color c = outlineColor;
                c.a = alpha * (currentIntensity / highlightIntensity);
                outlineMaterial.color = c;
            }
        }
    }

    /// <summary>
    /// Updates scale pulse effect.
    /// </summary>
    private void UpdateScalePulse()
    {
        if (!useScalePulse) return;

        if (isHighlighted)
        {
            float pulse = 1f + Mathf.Sin(Time.time * pulseSpeed) * pulseAmount;
            transform.localScale = originalScale * pulse;
        }
        else
        {
            transform.localScale = Vector3.Lerp(transform.localScale, originalScale, transitionSpeed * Time.deltaTime);
        }
    }

    /// <summary>
    /// Enables highlight effect.
    /// </summary>
    public void EnableHighlight()
    {
        isHighlighted = true;
    }

    /// <summary>
    /// Disables highlight effect.
    /// </summary>
    public void DisableHighlight()
    {
        isHighlighted = false;
    }

    /// <summary>
    /// Sets highlight state directly.
    /// </summary>
    public void SetHighlighted(bool highlighted)
    {
        isHighlighted = highlighted;
    }

    /// <summary>
    /// Gets current highlight state.
    /// </summary>
    public bool IsHighlighted() => isHighlighted;

    /// <summary>
    /// Sets highlight color dynamically.
    /// </summary>
    public void SetHighlightColor(Color color)
    {
        highlightColor = color;
        if (outlineMaterial != null)
        {
            outlineColor = color;
        }
    }

    private void OnDestroy()
    {
        // Cleanup created materials
        if (highlightMaterials != null)
        {
            foreach (Material mat in highlightMaterials)
            {
                if (mat != null)
                {
                    Destroy(mat);
                }
            }
        }

        if (outlineMaterial != null)
        {
            Destroy(outlineMaterial);
        }
    }
}
