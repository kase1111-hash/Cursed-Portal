// Auto-generated by CursedPortal AI Spec v1.0
// Source: Module M8 - Prop Animator

using UnityEngine;

/// <summary>
/// Handles idle animations for interactive props.
/// Supports floating, rotation, bobbing, and swaying effects.
/// </summary>
public class PropAnimator : MonoBehaviour
{
    [Header("Animation Types")]
    [SerializeField] private bool enableFloat = true;
    [SerializeField] private bool enableRotation = false;
    [SerializeField] private bool enableBob = false;
    [SerializeField] private bool enableSway = false;

    [Header("Float Settings")]
    [SerializeField] private float floatAmplitude = 0.1f;
    [SerializeField] private float floatSpeed = 1f;
    [SerializeField] private Vector3 floatAxis = Vector3.up;

    [Header("Rotation Settings")]
    [SerializeField] private Vector3 rotationAxis = Vector3.up;
    [SerializeField] private float rotationSpeed = 30f;
    [SerializeField] private bool useOscillatingRotation = false;
    [SerializeField] private float oscillationAngle = 15f;

    [Header("Bob Settings")]
    [SerializeField] private float bobAmplitude = 0.05f;
    [SerializeField] private float bobSpeed = 2f;
    [SerializeField] private AnimationCurve bobCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);

    [Header("Sway Settings")]
    [SerializeField] private float swayAngle = 5f;
    [SerializeField] private float swaySpeed = 1f;
    [SerializeField] private Vector3 swayAxis = Vector3.forward;

    [Header("Reactivity")]
    [SerializeField] private bool reactToHighlight = true;
    [SerializeField] private float highlightSpeedMultiplier = 1.5f;
    [SerializeField] private bool reactToSpook = true;
    [SerializeField] private float spookSpeedMultiplier = 0.2f;

    [Header("Random Offset")]
    [SerializeField] private bool useRandomOffset = true;

    // State
    private Vector3 startPosition;
    private Quaternion startRotation;
    private float timeOffset;
    private bool isHighlighted = false;
    private int currentSpookLevel = 0;
    private float currentSpeedMultiplier = 1f;

    private void Start()
    {
        startPosition = transform.localPosition;
        startRotation = transform.localRotation;

        // Random time offset for variety when multiple props exist
        if (useRandomOffset)
        {
            timeOffset = Random.Range(0f, 100f);
        }

        // Subscribe to spook events
        if (reactToSpook && EventManager.Instance != null)
        {
            EventManager.Instance.OnSpookLevelChanged += OnSpookLevelChanged;
        }
    }

    private void Update()
    {
        UpdateSpeedMultiplier();
        ApplyAnimations();
    }

    /// <summary>
    /// Updates the speed multiplier based on state.
    /// </summary>
    private void UpdateSpeedMultiplier()
    {
        float targetMultiplier = 1f;

        if (isHighlighted && reactToHighlight)
        {
            targetMultiplier = highlightSpeedMultiplier;
        }

        if (reactToSpook)
        {
            targetMultiplier += currentSpookLevel * spookSpeedMultiplier;
        }

        currentSpeedMultiplier = Mathf.Lerp(currentSpeedMultiplier, targetMultiplier, 3f * Time.deltaTime);
    }

    /// <summary>
    /// Applies all enabled animation effects.
    /// </summary>
    private void ApplyAnimations()
    {
        Vector3 positionOffset = Vector3.zero;
        Quaternion rotationOffset = Quaternion.identity;

        float time = (Time.time + timeOffset) * currentSpeedMultiplier;

        // Float animation
        if (enableFloat)
        {
            float floatOffset = Mathf.Sin(time * floatSpeed) * floatAmplitude;
            positionOffset += floatAxis.normalized * floatOffset;
        }

        // Bob animation
        if (enableBob)
        {
            float bobT = (Mathf.Sin(time * bobSpeed) + 1f) / 2f;
            float bobOffset = bobCurve.Evaluate(bobT) * bobAmplitude;
            positionOffset += Vector3.up * bobOffset;
        }

        // Rotation animation
        if (enableRotation)
        {
            if (useOscillatingRotation)
            {
                float oscillation = Mathf.Sin(time * rotationSpeed * Mathf.Deg2Rad) * oscillationAngle;
                rotationOffset = Quaternion.AngleAxis(oscillation, rotationAxis);
            }
            else
            {
                rotationOffset = Quaternion.AngleAxis(time * rotationSpeed, rotationAxis);
            }
        }

        // Sway animation
        if (enableSway)
        {
            float swayAmount = Mathf.Sin(time * swaySpeed) * swayAngle;
            rotationOffset *= Quaternion.AngleAxis(swayAmount, swayAxis);
        }

        // Apply position
        transform.localPosition = startPosition + positionOffset;

        // Apply rotation
        if (enableRotation || enableSway)
        {
            if (useOscillatingRotation || enableSway)
            {
                transform.localRotation = startRotation * rotationOffset;
            }
            else
            {
                // Continuous rotation ignores start rotation
                transform.localRotation = rotationOffset;
            }
        }
    }

    /// <summary>
    /// Handles spook level changes.
    /// </summary>
    private void OnSpookLevelChanged(int level)
    {
        currentSpookLevel = level;
    }

    /// <summary>
    /// Sets highlight state for animation reactivity.
    /// </summary>
    public void SetHighlighted(bool highlighted)
    {
        isHighlighted = highlighted;
    }

    /// <summary>
    /// Triggers a quick jitter effect.
    /// </summary>
    public void TriggerJitter(float duration = 0.5f, float intensity = 1f)
    {
        StartCoroutine(JitterCoroutine(duration, intensity));
    }

    private System.Collections.IEnumerator JitterCoroutine(float duration, float intensity)
    {
        float elapsed = 0f;
        Vector3 jitterPos = startPosition;

        while (elapsed < duration)
        {
            elapsed += Time.deltaTime;
            float t = 1f - (elapsed / duration);

            Vector3 jitter = new Vector3(
                Random.Range(-1f, 1f),
                Random.Range(-1f, 1f),
                Random.Range(-1f, 1f)
            ) * intensity * t * 0.05f;

            transform.localPosition = jitterPos + jitter;
            yield return null;
        }
    }

    /// <summary>
    /// Triggers a bump/impact effect.
    /// </summary>
    public void TriggerBump(Vector3 direction, float force = 1f)
    {
        StartCoroutine(BumpCoroutine(direction.normalized, force));
    }

    private System.Collections.IEnumerator BumpCoroutine(Vector3 direction, float force)
    {
        Vector3 bumpOffset = direction * force * 0.1f;
        float elapsed = 0f;
        float duration = 0.3f;

        // Quick bump out
        while (elapsed < duration * 0.3f)
        {
            elapsed += Time.deltaTime;
            float t = elapsed / (duration * 0.3f);
            transform.localPosition = startPosition + bumpOffset * t;
            yield return null;
        }

        // Slower return with overshoot
        elapsed = 0f;
        while (elapsed < duration * 0.7f)
        {
            elapsed += Time.deltaTime;
            float t = elapsed / (duration * 0.7f);
            float ease = 1f - Mathf.Pow(1f - t, 3f);
            transform.localPosition = Vector3.Lerp(startPosition + bumpOffset, startPosition, ease);
            yield return null;
        }

        transform.localPosition = startPosition;
    }

    /// <summary>
    /// Resets animation to starting state.
    /// </summary>
    public void ResetToStart()
    {
        transform.localPosition = startPosition;
        transform.localRotation = startRotation;
    }

    /// <summary>
    /// Sets a new start position (useful after moving prop).
    /// </summary>
    public void SetStartPosition(Vector3 position)
    {
        startPosition = position;
    }

    /// <summary>
    /// Sets animation parameters at runtime.
    /// </summary>
    public void SetFloatParams(float amplitude, float speed)
    {
        floatAmplitude = amplitude;
        floatSpeed = speed;
    }

    public void SetRotationParams(float speed, Vector3 axis)
    {
        rotationSpeed = speed;
        rotationAxis = axis;
    }

    public void SetSwayParams(float angle, float speed)
    {
        swayAngle = angle;
        swaySpeed = speed;
    }

    /// <summary>
    /// Enables/disables specific animation types.
    /// </summary>
    public void SetAnimationType(bool floating, bool rotating, bool bobbing, bool swaying)
    {
        enableFloat = floating;
        enableRotation = rotating;
        enableBob = bobbing;
        enableSway = swaying;
    }

    private void OnDestroy()
    {
        if (EventManager.Instance != null)
        {
            EventManager.Instance.OnSpookLevelChanged -= OnSpookLevelChanged;
        }
    }
}
